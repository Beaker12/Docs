<!doctype html> <html> <head> <meta charset=utf-8> <meta content="IE=edge,chrome=1" http-equiv=X-UA-Compatible> <meta name=viewport content="width=device-width, initial-scale=1, maximum-scale=1"> <title>API Documentation</title> <link href="../stylesheets/screen.css" rel=stylesheet media=screen /> <link href="../stylesheets/print.css" rel=stylesheet media=print /> <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script> <script src="../javascripts/all_nosearch.js"></script> </head> <body class="includes includes_rustlegacy_api_hooks"> <a href="#" id=nav-button> <span> NAV <img src="../images/navbar.png"/> </span> </a> <div class=tocify-wrapper> <img src="../images/logo.png"/> <div id=toc> </div> </div> <div class=page-wrapper> <div class=dark-box></div> <div class=content> <h1 id=rust-legacy-api-hooks>Rust Legacy API Hooks</h1> <h2 id=plugin-hooks>Plugin hooks</h2> <h3 id="init()">Init()</h3> <ul> <li>Called when the plugin is being loaded</li> <li>Other plugins may or may not be present, dependant on load order</li> <li>Other plugins WILL have been executed though, so globals exposed by them will be present</li> </ul> <h3 id="loaddefaultconfig()">LoadDefaultConfig()</h3> <ul> <li>Called when the config for the plugin should be initialized</li> <li>Only called if the config file does not already exist</li> </ul> <h3 id="unload()">Unload()</h3> <ul> <li>Called when the plugin is being unloaded</li> </ul> <h3 id="onpluginloaded(plugin-plugin)">OnPluginLoaded(Plugin plugin)</h3> <ul> <li>Called when a specific plugin has been loaded</li> </ul> <h3 id="onpluginunloaded(plugin-plugin)">OnPluginUnloaded(Plugin plugin)</h3> <ul> <li>Called when a specific plugin has been unloaded</li> </ul> <h2 id=general-hooks>General hooks</h2> <h3 id="oninitlogging()">OnInitLogging()</h3> <ul> <li>Called from ServerInit.Awake</li> <li>No return behavior</li> <li>Used internally by Oxide to start Unity logging</li> </ul> <h3 id="modifytags(string-oldtags)">ModifyTags(string oldtags)</h3> <ul> <li>Called from Rust.Steam.Server.GetTags</li> <li>Returning a string overrides the tags with new ones</li> <li>Used by RustLegacyCore and abstracted into BuildServerTags</li> </ul> <h3 id="buildservertags(ilist-tags)">BuildServerTags(IList<string> tags)</h3> <ul> <li>Called from RustLegacyCore.ModifyTags</li> <li>No return behavior</li> <li>Add tags to the list, they will be concat&rsquo;d at the end</li> </ul> <h3 id="onserverinitialized()">OnServerInitialized()</h3> <ul> <li>Called from ServerInit.Destroy through an additional component added by RustLegacyExtension</li> <li>No return behavior</li> <li>Called after the server startup has been completed and is awaiting connections</li> </ul> <h3 id="onserversave()">OnServerSave()</h3> <ul> <li>Called from ServerSaveManager.Save</li> <li>No return behavior</li> <li>Called before the server saves and rotates the .sav files</li> </ul> <h3 id="onservershutdown()">OnServerShutdown()</h3> <ul> <li>Called from global.quit</li> <li>No return behavior</li> <li>Called before the server starts the shutdown sequence</li> <li>This should generally not be used by plugins, instead use the Unload hook</li> </ul> <h3 id="onruncommand(consolesystem.arg-arg,-bool-wantreply)">OnRunCommand(ConsoleSystem.Arg arg, bool wantreply)</h3> <ul> <li>Called from ConsoleSystem.RunCommand</li> <li>Return true to override Rust&rsquo;s command handling system</li> <li>Useful for intercepting commands before they get to their intended target (like chat.say)</li> <li>Used by RustLegacyCore to implement chat commands</li> </ul> <h3 id=ondatablocksinitialized>OnDatablocksInitialized</h3> <ul> <li>Called from DatablockDictionary.Initialize</li> <li>No return behavior</li> <li>Called when all datablocks have been loaded</li> </ul> <h3 id="onresourcenodeloaded(resourcetarget-resource)">OnResourceNodeLoaded(ResourceTarget resource)</h3> <ul> <li>Called from ResourceTarget.Awake</li> <li>No return behavior</li> <li>Called when a resource is initializing</li> </ul> <h2 id=player-hooks>Player hooks</h2> <h3 id="onuserapprove(clientconnection-connection,-ulink.networkplayerapproval-approval,-connectionacceptor-acceptor)">OnUserApprove(ClientConnection connection, uLink.NetworkPlayerApproval approval, ConnectionAcceptor acceptor)</h3> <ul> <li>Called from ConnectionAcceptor.uLink_OnPlayerApproval</li> <li>Returning a non-null value overrides default behavior, plugin should call approval.Deny if it does this</li> <li>Used by RustLegacyCore and abstracted into CanClientLogin</li> </ul> <h3 id="canclientlogin(clientconnection-connection,-ulink.networkplayerapproval)">CanClientLogin(ClientConnection connection, uLink.NetworkPlayerApproval)</h3> <ul> <li>Called from RustLegacyCore.OnUserApprove</li> <li>Returning a uLink.NetworkConnectionError will reject the connection, returning anything else will allow the connection</li> </ul> <h3 id="onplayerconnected(netuser-netuser)">OnPlayerConnected(NetUser netuser)</h3> <ul> <li>Called from ServerManagement.OnUserConnected</li> <li>No return behavior</li> <li>Called before the player object is created, but after the player has been approved</li> </ul> <h3 id="onplayerdisconnected(ulink.networkplayer-networkplayer)">OnPlayerDisconnected(uLink.NetworkPlayer networkplayer)</h3> <ul> <li>Called from ConnectionAcceptor.uLink_OnPlayerDisconnected</li> <li>No return behavior</li> <li>Called after the player has disconnected from the server</li> </ul> <h3 id="onplayerspawn(playerclient-client,-bool-usecamp,-rustproto.avatar-avatar)">OnPlayerSpawn(PlayerClient client, bool usecamp, RustProto.Avatar avatar)</h3> <ul> <li>Called from ServerManagement.SpawnPlayer</li> <li>No return behavior</li> <li>Called when the player spawns</li> </ul> <h3 id="onplayerchat(netuser-netuser,-string-message)">OnPlayerChat(NetUser netuser, string message)</h3> <ul> <li>Called from RustLegacyCore.OnRunCommand</li> <li>Returning a non-null value overrides default behavior of chat, not commands</li> </ul> <h3 id="onitemcraft(craftinginventory-inventory,-blueprintdatablock-blueprint,-int-amount,-ulong-starttime)">OnItemCraft(CraftingInventory inventory, BlueprintDataBlock blueprint, int amount, ulong starttime)</h3> <ul> <li>Called from CraftingInventory.OnItemCraft</li> <li>Returning non-null overrides default behavior</li> <li>Called when a player starts crafting an item</li> </ul> <h3 id="onblueprintuse(blueprintdatablock-blueprint,-iblueprintitem-item)">OnBlueprintUse(BlueprintDataBlock blueprint, IBlueprintItem item)</h3> <ul> <li>Called from BlueprintDataBlock.UseItem</li> <li>Returning non-null overrides default behavior</li> <li>Called when a player tries to study a blueprint</li> </ul> <h3 id="onresearchitem(researchtoolitem-item,-iinventoryitem-otheritem)">OnResearchItem(ResearchToolItem<T> item, IInventoryItem otheritem)</h3> <ul> <li>Called from ResearchToolItem<T>.TryCombine</li> <li>Returning a InventoryItem.MergeResult will cancel default behavior</li> <li>Called when a player tries to research an item</li> </ul> <h3 id="onplayervoice(netuser-netuser,-list-players)">OnPlayerVoice(NetUser netuser, List<uLink.NetworkPlayer> players)</h3> <ul> <li>Called from RustLegacyCore.OnClientSpeak</li> <li>Called when a player uses in-game voice communication</li> </ul> <h2 id=entity-hooks>Entity hooks</h2> <h3 id="onairdrop(vector3-position)">OnAirdrop(Vector3 position)</h3> <ul> <li>Called from SupplyDropZone.CallAirDropAt</li> <li>No return behavior</li> <li>Called when an airdrop has been called</li> </ul> <h3 id="onprocessdamageevent(takedamage-takedamage,-damageevent-damage)">OnProcessDamageEvent(TakeDamage takedamage, DamageEvent damage)</h3> <ul> <li>Called from TakeDamage.ProcessDamageEvent</li> <li>Returning a non-null value overrides default behavior</li> <li>Used by RustLegacyCore and abstracted in ModifyDamage, OnHurt and OnKilled</li> </ul> <h3 id="modifydamage(takedamage-takedamage,-damageevent-damage)">ModifyDamage(TakeDamage takedamage, DamageEvent damage)</h3> <ul> <li>Called from RustLegacyCore.OnProcessDamageEvent</li> <li>Returning a non-null value overrides default behavior</li> <li>Called when any kind of entity takes damage</li> <li>Modify the DamageEvent object and return it to &lsquo;apply&rsquo; the modifications</li> </ul> <h3 id="onhurt(takedamage-takedamage,-damageevent-damage)">OnHurt(TakeDamage takedamage, DamageEvent damage)</h3> <ul> <li>Called from RustLegacyCore.OnProcessDamageEvent</li> <li>No return behavior</li> <li>Called when any kind of entity takes damage</li> </ul> <h3 id="onkilled(takedamage-takedamage,-damageevent-damage)">OnKilled(TakeDamage takedamage, DamageEvent damage)</h3> <ul> <li>Called from RustLegacyCore.OnProcessDamageEvent</li> <li>No return behavior</li> <li>Called when any kind of entity was killed</li> </ul> <h2 id=item-hooks>Item hooks</h2> <h3 id="onitemadded(inventory-inventory,-int-slot,-iinventoryitem-item)">OnItemAdded(Inventory inventory, int slot, IInventoryItem item)</h3> <ul> <li>Called from Inventory.ItemAdded</li> <li>No return behavior</li> <li>Called when an item was added to an inventory</li> </ul> <h3 id="onitemremoved(inventory-inventory,-int-slot,-iinventoryitem-item)">OnItemRemoved(Inventory inventory, int slot, IInventoryItem item)</h3> <ul> <li>Called from Inventory.ItemRemoved</li> <li>No return behavior</li> <li>Called when an item was removed from an inventory</li> </ul> <h3 id="onitemdeployed(deployableobject-deployable,-netuser-user)">OnItemDeployed(DeployableObject deployable, NetUser user)</h3> <ul> <li>Called from DeployableItemDataBlock.DoAction1</li> <li>No return behavior</li> <li>Called when an item was deployed by a player</li> </ul> <h2 id=structure-hooks>Structure hooks</h2> <h3 id="onstructurebuilt(structurecomponent-structure,-netuser-user)">OnStructureBuilt(StructureComponent structure, NetUser user)</h3> <ul> <li>Called from StructureComponentDataBlock.DoAction1</li> <li>No return behavior</li> <li>Called when an structure was built by a player</li> </ul> <h3 id="onstructuredecay(structuremaster-master)">OnStructureDecay(StructureMaster master)</h3> <ul> <li>Called from StructureMaster.DoDecay</li> <li>Returning a non-null value overrides default behavior</li> <li>Called when a structure tries to decay</li> </ul> <h3 id="ondoortoggle(basicdoor-door,-ulong-timestamp,-controllable-controllable)">OnDoorToggle(BasicDoor door, ulong timestamp, Controllable controllable)</h3> <ul> <li>Called from BasicDoor.ToggleStateServer</li> <li>Returning true allows the state of the door to be toggled and returning false denies the state of the door being toggled, returning anything else will resume default behavior</li> <li>Called when a player attempts to open or close a door</li> </ul> </div> <div class=dark-box> </div> </div> </body> </html>