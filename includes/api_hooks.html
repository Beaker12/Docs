<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>API Documentation</title>

    <link href="../stylesheets/screen.css" rel="stylesheet" type="text/css" media="screen" />
    <link href="../stylesheets/print.css" rel="stylesheet" type="text/css" media="print" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
      <script src="../javascripts/all_nosearch.js" type="text/javascript"></script>

  </head>

  <body class="includes includes_api_hooks">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="../images/navbar.png" />
      </span>
    </a>
    <div class="tocify-wrapper">
      <img src="../images/logo.png" />
      <div id="toc">
      </div>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id="api-hooks">API Hooks</h1>

<h2 id="plugin-hooks">Plugin hooks</h2>

<h3 id="init()">Init()</h3>

<ul>
<li>Called when the plugin is being loaded</li>
<li>Other plugins may or may not be present, dependant on load order</li>
<li>Other plugins WILL have been executed though, so globals exposed by them will be present</li>
</ul>

<h3 id="loaddefaultconfig()">LoadDefaultConfig()</h3>

<ul>
<li>Called when the config for the plugin should be initialized</li>
<li>Only called if the config file does not already exist</li>
</ul>

<h3 id="unload()">Unload()</h3>

<ul>
<li>Called when the plugin is being unloaded</li>
</ul>

<h3 id="onpluginloaded(plugin)">OnPluginLoaded(plugin)</h3>

<ul>
<li>Called when specified plugin has been loaded</li>
</ul>

<h3 id="onpluginunloaded(plugin)">OnPluginUnloaded(plugin)</h3>

<ul>
<li>Called when specified plugin has been unloaded</li>
</ul>

<h2 id="general-hooks">General hooks</h2>

<h3 id="oninitlogging()">OnInitLogging()</h3>

<ul>
<li>Called from Assembly-CSharp/Bootstrap.StartupShared</li>
<li>No return behavior</li>
<li>Used internally by Oxide to start Unity logging</li>
</ul>

<h3 id="modifytags(string-oldtags)">ModifyTags(string oldtags)</h3>

<ul>
<li>Called from Assembly-CSharp/ServerMgr.UpdateServerInformation</li>
<li>Returning a string overrides the tags with new ones</li>
<li>Used by RustCore and abstracted into BuildServerTags</li>
</ul>

<h3 id="buildservertags(ilist-tags)">BuildServerTags(IList<string> tags)</h3>

<ul>
<li>Called from RustCore.ModifyTags</li>
<li>No return behavior</li>
<li>Add tags to the list, they will be concat&rsquo;d at the end</li>
</ul>

<h3 id="onserverinitialized()">OnServerInitialized()</h3>

<ul>
<li>Called from Assembly-CSharp/ServerMgr</li>
<li>No return behavior</li>
<li>Called after the server startup has been completed and is awaiting connections</li>
</ul>

<h3 id="ontick()">OnTick()</h3>

<ul>
<li>Called from Assembly-CSharp/ServerMgr.DoTick</li>
<li>No return behavior</li>
<li>Called every tick (defined by the tickrate of the server?)</li>
</ul>

<h3 id="onruncommand(facepunch/consolesystem.arg-arg)">OnRunCommand(Facepunch/ConsoleSystem.Arg arg)</h3>

<ul>
<li>Called from Facepunch/ConsoleSystem.Run, Facepunch/ConsoleSystem.RunUnrestricted and Facepunch/ConsoleSystem.ClientRun</li>
<li>Return true to override Rust&rsquo;s command handling system</li>
<li>Useful for intercepting commands before they get to their intended target (like chat.say)</li>
<li>Used by RustCore to implement chat commands</li>
</ul>

<h2 id="player-hooks">Player hooks</h2>

<h3 id="onuserapprove(facepunch/network.connection-connection)">OnUserApprove(Facepunch/Network.Connection connection)</h3>

<ul>
<li>Called from Assembly-CSharp/ConnectionAuth.OnNewConnection</li>
<li>Returning a non-null value overrides default behavior, plugin should call Reject if it does this</li>
<li>Used by RustCore and abstracted into CanClientLogin</li>
</ul>

<h3 id="canclientlogin(facepunch/network.connection-connection)">CanClientLogin(Facepunch/Network.Connection connection)</h3>

<ul>
<li>Called from RustCore.OnUserApprove</li>
<li>Returning true will allow the connection, returning nothing will by default allow the connection, returning anything else will reject it with an error message</li>
<li>Returning a string will use the string as the error message</li>
</ul>

<h3 id="onfindspawnpoint()">OnFindSpawnPoint()</h3>

<ul>
<li>Called from Assembly-CSharp/ServerMgr</li>
<li>Return a Assembly-CSharp/BasePlayer.SpawnPoint object to use that spawnpoint</li>
<li>Useful for controlling player spawnpoints (like making all spawns occur in a set area)</li>
</ul>

<h3 id="onplayerconnected(facepunch/network.message-packet)">OnPlayerConnected(Facepunch/Network.Message packet)</h3>

<ul>
<li>Called from Assembly-CSharp/ServerMgr</li>
<li>No return behavior</li>
<li>Called before the player object is created, but after the player has been approved to join the game</li>
<li>Can get the connection from packet.connection</li>
</ul>

<h3 id="onplayerinit(assembly-csharp/baseplayer-player)">OnPlayerInit(Assembly-CSharp/BasePlayer player)</h3>

<ul>
<li>Called from Assembly-CSharp/BasePlayer</li>
<li>No return behavior</li>
<li>Called when the player is initialising (after they&rsquo;ve connected, before they wake up)</li>
</ul>

<h3 id="onplayerspawn(assembly-csharp/baseplayer-player,-facepunch/network.connection-connection)">OnPlayerSpawn(Assembly-CSharp/BasePlayer player, Facepunch/Network.Connection connection)</h3>

<ul>
<li>Called when the player spawns (specifically when they click the &ldquo;Respawn&rdquo; button)</li>
<li>No return behavior</li>
<li>ONLY called when the player is transitioning from dead to not-dead, so not when they&rsquo;re waking up</li>
<li>This means it&rsquo;s possible for a player to connect and disconnect from a server without OnPlayerSpawn ever triggering for them</li>
</ul>

<h3 id="onplayerchat(assembly-csharp/chat.say-arg)">OnPlayerChat(Assembly-CSharp/chat.say arg)</h3>

<ul>
<li>Called from Assembly-CSharp/chat.say</li>
<li>Returning a non-null value overrides default behavior of chat, not commands</li>
</ul>

<h3 id="onrunplayermetabolism(assembly-csharp/playermetabolism-metabolism)">OnRunPlayerMetabolism(Assembly-CSharp/PlayerMetabolism metabolism)</h3>

<ul>
<li>Called before a metabolism update occurs for the specified player</li>
<li>Returning true cancels the update</li>
<li>Metabolism update consists of managing the player&rsquo;s temperature, health etc</li>
<li>You can use this to turn off or change certain aspects of the metabolism, either by editing values before returning, or taking complete control of the method</li>
<li>Access the player object using metabolism:GetComponent(&ldquo;BasePlayer&rdquo;)</li>
</ul>

<h3 id="onplayerattack(assembly-csharp/baseplayer-attacker,-assembly-csharp/hitinfo-hitinfo)">OnPlayerAttack(Assembly-CSharp/BasePlayer attacker, Assembly-CSharp/HitInfo hitinfo)</h3>

<ul>
<li>Called from Assembly-CSharp/BasePlayer</li>
<li>Returning true cancels the attack</li>
<li>Useful for modifying an attack before it goes out</li>
<li>hitinfo.HitEntity should be the entity that this attack would hit</li>
</ul>

<h3 id="onplayerloot(assembly-csharp/playerloot-lootinventory,-assembly-csharp/baseentity-targetentity)">OnPlayerLoot(Assembly-CSharp/PlayerLoot lootinventory, Assembly-CSharp/BaseEntity targetentity)</h3>

<ul>
<li>Called from Assembly-CSharp/PlayerLoot</li>
<li>No return behavior</li>
<li>Called when the player starts looting an entity</li>
</ul>

<h3 id="onplayerloot(assembly-csharp/playerloot-lootinventory,-assembly-csharp/baseplayer-targetplayer)">OnPlayerLoot(Assembly-CSharp/PlayerLoot lootinventory, Assembly-CSharp/BasePlayer targetplayer)</h3>

<ul>
<li>Called from Assembly-CSharp/PlayerLoot</li>
<li>No return behavior</li>
<li>Called when the player starts looting another player</li>
</ul>

<h3 id="onplayerloot(assembly-csharp/playerloot-lootinventory,-assembly-csharp/item-targetitem)">OnPlayerLoot(Assembly-CSharp/PlayerLoot lootinventory, Assembly-CSharp/Item targetitem)</h3>

<ul>
<li>Called from Assembly-CSharp/PlayerLoot</li>
<li>No return behavior</li>
<li>Called when the player starts looting an item</li>
</ul>

<h3 id="onplayerdisconnected(assembly-csharp/baseplayer-player)">OnPlayerDisconnected(Assembly-CSharp/BasePlayer player)</h3>

<ul>
<li>Called from Assembly-CSharp/ServerMgr</li>
<li>No return behavior</li>
<li>Called before the player object is created, but after the player has been approved to join the game</li>
</ul>

<h2 id="entity-hooks">Entity hooks</h2>

<h3 id="onentityspawn(unityengine/monobehavior-entity)">OnEntitySpawn(UnityEngine/Monobehavior entity)</h3>

<ul>
<li>Called from Assembly-CSharp/BaseNetworkable</li>
<li>No return behavior</li>
<li>Called when any networked entity is spawned (including trees)</li>
</ul>

<h3 id="onentityattacked(unityengine/monobehavior-entity,-assembly-csharp/hitinfo-hitinfo)">OnEntityAttacked(UnityEngine/Monobehavior entity, Assembly-CSharp/HitInfo hitinfo)</h3>

<ul>
<li>Called from multiple places, each entity&rsquo;s attack handler basically</li>
<li>Returning non-null value overrides default server behavior (useful for godmode etc)</li>
<li>Alternatively, modify the hitinfo object to change the damage</li>
<li>It should be ok to set the damage to 0, but if you don&rsquo;t return non-null, the player&rsquo;s client will receive a damage indicator (if entity is a BasePlayer)</li>
<li>hitinfo has all kinds of useful things in it, such as hitinfo.Weapon, hitinfo.damageAmount or hitinfo.damageType</li>
<li>Currently implemented for: BasePlayer, BaseAnimal</li>
</ul>

<h3 id="onentitydeath(unityengine/monobehavior-entity,-assembly-csharp/hitinfo-hitinfo)">OnEntityDeath(UnityEngine/Monobehavior entity, Assembly-CSharp/HitInfo hitinfo)</h3>

<ul>
<li>Called from multiple places, each entity&rsquo;s death handler basically</li>
<li>No return behavior</li>
<li>hitinfo might be null, check it before use</li>
<li>Editing hitinfo probably has no effect</li>
<li>Currently implemented for: BasePlayer, BaseAnimal</li>
</ul>

<h3 id="onentityenter(assembly-csharp/triggerbase-triggerbase,-assembly-csharp/baseentity-entity)">OnEntityEnter(Assembly-CSharp/TriggerBase triggerbase, Assembly-CSharp/BaseEntity entity)</h3>

<ul>
<li>Called from Assembly-CSharp/TriggerBase</li>
<li>No return behavior</li>
<li>Called when an entity enters an area/zone (building privilege zone, water area, radiation zone, hurt zone, etc)</li>
</ul>

<h3 id="onentityleave(assembly-csharp/triggerbase-triggerbase,-assembly-csharp/baseentity-entity)">OnEntityLeave(Assembly-CSharp/TriggerBase triggerbase, Assembly-CSharp/BaseEntity entity)</h3>

<ul>
<li>Called from Assembly-CSharp/TriggerBase</li>
<li>No return behavior</li>
<li>Called when an entity leaves an area/zone (building privilege zone, water area, radiation zone, hurt zone, etc)</li>
</ul>

<h2 id="item-hooks">Item hooks</h2>

<h3 id="onitemcraft(assembly-csharp/itemcrafttask-item)">OnItemCraft(Assembly-CSharp/ItemCraftTask item)</h3>

<ul>
<li>Called from Assembly-CSharp/ItemCrafter</li>
<li>Return a Assembly-CSharp/ItemCraftTask object to modify behavior</li>
<li>Called right after an item has started crafting</li>
</ul>

<h3 id="onitemdeployed(assembly-csharp/deployer-deployer,-assembly-csharp/baseentity-deployedentity)">OnItemDeployed(Assembly-CSharp/Deployer deployer, Assembly-CSharp/BaseEntity deployedentity)</h3>

<ul>
<li>Assembly-CSharp/Deployer</li>
<li>No return behavior</li>
<li>Called right after an item has been deployed</li>
</ul>

<h3 id="onitemaddedtocontainer(assembly-csharp/itemcontainer-container,-assembly-csharp/item-item)">OnItemAddedToContainer(Assembly-CSharp/ItemContainer container, Assembly-CSharp/Item item)</h3>

<ul>
<li>Called from Assembly-CSharp/ItemContainer</li>
<li>No return behavior</li>
<li>Called right after an item was added to a container</li>
<li>An entire stack has to be created, not just adding more wood to a wood stack for example</li>
</ul>

<h3 id="onitemremovedfromcontainer(assembly-csharp/itemcontainer-container,-assembly-csharp/item-item)">OnItemRemovedFromContainer(Assembly-CSharp/ItemContainer container, Assembly-CSharp/Item item)</h3>

<ul>
<li>Called from Assembly-CSharp/ItemContainer</li>
<li>No return behavior</li>
<li>Called right after an item was removed from a container</li>
<li>The entire stack has to be removed for this to be called, not just a little bit</li>
</ul>

<h3 id="ongather(assembly-csharp/resourcedispenser-dispenser,-assembly-csharp/baseentity-entity,-assembly-csharp/item-item)">OnGather(Assembly-CSharp/ResourceDispenser dispenser, Assembly-CSharp/BaseEntity entity, Assembly-CSharp/Item item)</h3>

<ul>
<li>Assembly-CSharp/ResourceDispenser</li>
<li>No return behavior</li>
<li>Called before the player is given items from a resource</li>
</ul>

<h2 id="structure-hooks">Structure hooks</h2>

<h3 id="canopendoor(assembly-csharp/baseplayer-player,-assembly-csharp/baselock-door)">CanOpenDoor(Assembly-CSharp/BasePlayer player, Assembly-CSharp/BaseLock door)</h3>

<ul>
<li>Called from Assembly-CSharp/BaseLock</li>
<li>Returning true will allow door usage, nothing will by default will allow door usage, returning anything else will reject door usage</li>
</ul>

<h3 id="canopendoor(assembly-csharp/baseplayer-player,-assembly-csharp/codelock-code)">CanOpenDoor(Assembly-CSharp/BasePlayer player, Assembly-CSharp/CodeLock code)</h3>

<ul>
<li>Called from Assembly-CSharp/CodeLock</li>
<li>Returning true will allow door code usage, nothing will by default will allow door code usage, returning anything else will reject door code usage</li>
</ul>

<h3 id="canopendoor(assembly-csharp/baseplayer-player,-assembly-csharp/keylock-key)">CanOpenDoor(Assembly-CSharp/BasePlayer player, Assembly-CSharp/KeyLock key)</h3>

<ul>
<li>Called from Assembly-CSharp/KeyLock</li>
<li>Returning true will allow door key usage, nothing will by default will allow door key usage, returning anything else will reject door key usage</li>
</ul>

<h3 id="onentitybuilt(assembly-csharp/baseplayer-player,-unityengine/gameobject-gameobject)">OnEntityBuilt(Assembly-CSharp/BasePlayer player, UnityEngine/GameObject gameobject)</h3>

<ul>
<li>Called from Assembly-CSharp/Item.Modules.Planner</li>
<li>No return behavior</li>
<li>Called when any structure is built (walls, ceilings, stairs, etc)</li>
</ul>

      </div>
      <div class="dark-box">
      </div>
    </div>
  </body>
</html>
