<!doctype html> <html> <head> <meta charset=utf-8> <meta content="IE=edge,chrome=1" http-equiv=X-UA-Compatible> <meta name=viewport content="width=device-width, initial-scale=1, maximum-scale=1"> <title>API Documentation</title> <link href="../stylesheets/screen.css" rel=stylesheet media=screen /> <link href="../stylesheets/print.css" rel=stylesheet media=print /> <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script> <script src="../javascripts/all_nosearch.js"></script> </head> <body class="includes includes_rust_api_hooks"> <a href="#" id=nav-button> <span> NAV <img src="../images/navbar.png"/> </span> </a> <div class=tocify-wrapper> <img src="../images/logo.png"/> <div id=toc> </div> </div> <div class=page-wrapper> <div class=dark-box></div> <div class=content> <h1 id=rust-api-hooks>Rust API Hooks</h1> <h2 id=plugin-hooks>Plugin hooks</h2> <h3 id="init()">Init()</h3> <ul> <li>Called when the plugin is being loaded</li> <li>Other plugins may or may not be present, dependant on load order</li> <li>Other plugins WILL have been executed though, so globals exposed by them will be present</li> </ul> <h3 id="loaddefaultconfig()">LoadDefaultConfig()</h3> <ul> <li>Called when the config for the plugin should be initialized</li> <li>Only called if the config file does not already exist</li> </ul> <h3 id="unload()">Unload()</h3> <ul> <li>Called when the plugin is being unloaded</li> </ul> <h3 id="onpluginloaded(plugin)">OnPluginLoaded(plugin)</h3> <ul> <li>Called when specified plugin has been loaded</li> </ul> <h3 id="onpluginunloaded(plugin)">OnPluginUnloaded(plugin)</h3> <ul> <li>Called when specified plugin has been unloaded</li> </ul> <h2 id=general-hooks>General hooks</h2> <h3 id="oninitlogging()">OnInitLogging()</h3> <ul> <li>Called from Bootstrap.StartupShared</li> <li>No return behavior</li> <li>Used internally by Oxide to start Unity logging</li> </ul> <h3 id="modifytags(string-oldtags)">ModifyTags(string oldtags)</h3> <ul> <li>Called from ServerMgr.UpdateServerInformation</li> <li>Returning a string overrides the tags with new ones</li> <li>Used by RustCore and abstracted into BuildServerTags</li> </ul> <h3 id="buildservertags(ilist-tags)">BuildServerTags(IList<string> tags)</h3> <ul> <li>Called from RustCore.ModifyTags</li> <li>No return behavior</li> <li>Add tags to the list, they will be concat&rsquo;d at the end</li> </ul> <h3 id="onterraininitialized()">OnTerrainInitialized()</h3> <ul> <li>Called from InitializePVT.Apply</li> <li>No return behavior</li> <li>Called after the terrain generation process has completed</li> </ul> <h3 id="onserverinitialized()">OnServerInitialized()</h3> <ul> <li>Called from ServerMgr.Initialize</li> <li>No return behavior</li> <li>Called after the server startup has been completed and is awaiting connections</li> </ul> <h3 id="onserversave()">OnServerSave()</h3> <ul> <li>Called from SaveRestore.DoAutomatedSave</li> <li>No return behavior</li> <li>Called before the server saves and rotates the .sav files</li> </ul> <h3 id="onservershutdown()">OnServerShutdown()</h3> <ul> <li>Called from ConsoleGlobal</li> <li>No return behavior</li> <li>Called before the server starts the shutdown sequence</li> <li>This should generally not be used by plugins, instead use the Unload hook</li> <li>This is the direct replacement to OnServerQuit, which has since been removed</li> </ul> <h3 id="ontick()">OnTick()</h3> <ul> <li>Called from ServerMgr.DoTick</li> <li>No return behavior</li> <li>Called every tick (defined by the tickrate of the server?)</li> </ul> <h3 id="onruncommand(consolesystem.arg-arg)">OnRunCommand(ConsoleSystem.Arg arg)</h3> <ul> <li>Called from ConsoleSystem.Run_Internal, ConsoleSystem.Run_Unrestricted, and ConsoleSystem.SystemRealm_Normal</li> <li>Return true to override Rust&rsquo;s command handling system</li> <li>Useful for intercepting commands before they get to their intended target (like chat.say)</li> <li>Used by RustCore to implement chat commands</li> </ul> <h2 id=player-hooks>Player hooks</h2> <h3 id="onuserapprove(network.connection-connection)">OnUserApprove(Network.Connection connection)</h3> <ul> <li>Called from ConnectionAuth.OnNewConnection</li> <li>Returning a non-null value overrides default behavior, plugin should call Reject if it does this</li> <li>Used by RustCore and abstracted into CanClientLogin</li> </ul> <h3 id="canclientlogin(network.connection-connection)">CanClientLogin(Network.Connection connection)</h3> <ul> <li>Called from RustCore.OnUserApprove</li> <li>Returning true will allow the connection, returning nothing will by default allow the connection, returning anything else will reject it with an error message</li> <li>Returning a string will use the string as the error message</li> </ul> <h3 id="onplayerconnected(network.message-packet)">OnPlayerConnected(Network.Message packet)</h3> <ul> <li>Called from ServerMgr.ClientReady</li> <li>No return behavior</li> <li>Called before the player object is created, but after the player has been approved to join the game</li> <li>Can get the connection from packet.connection</li> </ul> <h3 id="onplayerdisconnected(baseplayer-player)">OnPlayerDisconnected(BasePlayer player)</h3> <ul> <li>Called from BasePlayer.OnDisconnected</li> <li>No return behavior</li> <li>Called before the player object is created, but after the player has been approved to join the game</li> </ul> <h3 id="onplayerinit(baseplayer-player)">OnPlayerInit(BasePlayer player)</h3> <ul> <li>Called from BasePlayer.PlayerInit</li> <li>No return behavior</li> <li>Called when the player is initialising (after they&rsquo;ve connected, before they wake up)</li> </ul> <h3 id="onfindspawnpoint()">OnFindSpawnPoint()</h3> <ul> <li>Called from ServerMgr.BasePlayer/SpawnPoint</li> <li>Return a BasePlayer.SpawnPoint object to use that spawnpoint</li> <li>Useful for controlling player spawnpoints (like making all spawns occur in a set area)</li> </ul> <h3 id="onplayerrespawned(baseplayer-player,-network.connection-connection)">OnPlayerRespawned(BasePlayer player, Network.Connection connection)</h3> <ul> <li>Called from BasePlayer.Respawn</li> <li>Called when the player spawns (specifically when they click the &ldquo;Respawn&rdquo; button)</li> <li>No return behavior</li> <li>ONLY called after the player has transitioned from dead to not-dead, so not when they&rsquo;re waking up</li> <li>This means it&rsquo;s possible for a player to connect and disconnect from a server without OnPlayerRespawned ever triggering for them</li> </ul> <h3 id="onplayerchat(consolesystem.arg-arg)">OnPlayerChat(ConsoleSystem.Arg arg)</h3> <ul> <li>Called from chat.say</li> <li>Returning a non-null value overrides default behavior of chat, not commands</li> </ul> <h3 id="onrunplayermetabolism(playermetabolism-metabolism)">OnRunPlayerMetabolism(PlayerMetabolism metabolism)</h3> <ul> <li>Called from PlayerMetabolism.RunMetabolism</li> <li>Called before a metabolism update occurs for the specified player</li> <li>Returning true cancels the update</li> <li>Metabolism update consists of managing the player&rsquo;s temperature, health etc.</li> <li>You can use this to turn off or change certain aspects of the metabolism, either by editing values before returning, or taking complete control of the method</li> <li>Access the player object using metabolism:GetComponent(&ldquo;BasePlayer&rdquo;)</li> </ul> <h3 id="onplayerattack(baseplayer-attacker,-hitinfo-hitinfo)">OnPlayerAttack(BasePlayer attacker, HitInfo hitInfo)</h3> <ul> <li>Called from BasePlayer.SharedProjectileAttack and BaseMelee.DoAttackShared</li> <li>Returning true cancels the attack</li> <li>Useful for modifying an attack before it goes out</li> <li>hitInfo.HitEntity should be the entity that this attack would hit</li> </ul> <h3 id="onplayerloot(playerloot-lootinventory,-baseentity-targetentity)">OnPlayerLoot(PlayerLoot lootInventory, BaseEntity targetEntity)</h3> <ul> <li>Called from PlayerLoot.StartLootingEntity</li> <li>No return behavior</li> <li>Called when the player starts looting an entity</li> </ul> <h3 id="onplayerloot(playerloot-lootinventory,-baseplayer-targetplayer)">OnPlayerLoot(PlayerLoot lootInventory, BasePlayer targetPlayer)</h3> <ul> <li>Called from PlayerLoot.StartLootingPlayer</li> <li>No return behavior</li> <li>Called when the player starts looting another player</li> </ul> <h3 id="onplayerloot(playerloot-lootinventory,-item-targetitem)">OnPlayerLoot(PlayerLoot lootInventory, Item targetItem)</h3> <ul> <li>Called from PlayerLoot.StartLootingItem</li> <li>No return behavior</li> <li>Called when the player starts looting an item</li> </ul> <h2 id=entity-hooks>Entity hooks</h2> <h3 id="onentityspawned(basenetworkable-entity)">OnEntitySpawned(BaseNetworkable entity)</h3> <ul> <li>Called from BaseNetworkable.Spawn</li> <li>No return behavior</li> <li>Called after any networked entity has spawned (including trees)</li> </ul> <h3 id="onentityattacked(basecombatentity-entity,-hitinfo-hitinfo)">OnEntityAttacked(BaseCombatEntity entity, HitInfo hitInfo)</h3> <ul> <li>Called from BaseCombatEntity.Hurt</li> <li>Returning non-null value overrides default server behavior (useful for godmode etc.)</li> <li>Alternatively, modify the hitInfo object to change the damage</li> <li>It should be okay to set the damage to 0, but if you don&rsquo;t return non-null, the player&rsquo;s client will receive a damage indicator (if entity is a BasePlayer)</li> <li>hitInfo has all kinds of useful things in it, such as hitInfo.Weapon, hitInfo.damageAmount or hitInfo.damageType</li> <li>Currently implemented for: BasePlayer, BaseAnimal</li> </ul> <h3 id="onentitydeath(basecombatentity-entity,-hitinfo-hitinfo)">OnEntityDeath(BaseCombatEntity entity, HitInfo hitInfo)</h3> <ul> <li>Called from BaseCombatEntity.Die</li> <li>No return behavior</li> <li>hitInfo might be null, check it before use</li> <li>Editing hitInfo probably has no effect</li> <li>Currently implemented for: BasePlayer, BaseAnimal</li> </ul> <h3 id="onentityenter(triggerbase-triggerbase,-baseentity-entity)">OnEntityEnter(TriggerBase triggerBase, BaseEntity entity)</h3> <ul> <li>Called from TriggerBase.OnEntityEnter</li> <li>No return behavior</li> <li>Called when an entity enters an area/zone (building privilege zone, water area, radiation zone, hurt zone, etc.)</li> </ul> <h3 id="onentityleave(triggerbase-triggerbase,-baseentity-entity)">OnEntityLeave(TriggerBase triggerBase, BaseEntity entity)</h3> <ul> <li>Called from TriggerBase.OnEntityLeave</li> <li>No return behavior</li> <li>Called when an entity leaves an area/zone (building privilege zone, water area, radiation zone, hurt zone, etc.)</li> </ul> <h2 id=item-hooks>Item hooks</h2> <h3 id="onitemcraft(itemcrafttask-item)">OnItemCraft(ItemCraftTask item)</h3> <ul> <li>Called from ItemCrafter.CraftItem</li> <li>Return a ItemCraftTask object to modify behavior</li> <li>Called right after an item has started crafting</li> </ul> <h3 id="onitemdeployed(deployer-deployer,-baseentity-deployedentity)">OnItemDeployed(Deployer deployer, BaseEntity deployedEntity)</h3> <ul> <li>Called from Deployer.DoDeploy_Regular and Deployer.DoDeploy_Slot</li> <li>No return behavior</li> <li>Called right after an item has been deployed</li> </ul> <h3 id="onitemaddedtocontainer(itemcontainer-container,-item-item)">OnItemAddedToContainer(ItemContainer container, Item item)</h3> <ul> <li>Called from ItemContainer.Insert</li> <li>No return behavior</li> <li>Called right after an item was added to a container</li> <li>An entire stack has to be created, not just adding more wood to a wood stack for example</li> </ul> <h3 id="onitemremovedfromcontainer(itemcontainer-container,-item-item)">OnItemRemovedFromContainer(ItemContainer container, Item item)</h3> <ul> <li>Called from ItemContainer.Remove</li> <li>No return behavior</li> <li>Called right after an item was removed from a container</li> <li>The entire stack has to be removed for this to be called, not just a little bit</li> </ul> <h3 id="onconsumableuse(item-item)">OnConsumableUse(Item item)</h3> <ul> <li>Called from Item.UseOneItem</li> <li>No return behavior</li> <li>Called right after a consumable item is used</li> </ul> <h3 id="ongather(resourcedispenser-dispenser,-baseentity-entity,-item-item)">OnGather(ResourceDispenser dispenser, BaseEntity entity, Item item)</h3> <ul> <li>Called from ResourceDispenser.GiveResourceFromItem</li> <li>No return behavior</li> <li>Called before the player is given items from a resource</li> </ul> <h2 id=structure-hooks>Structure hooks</h2> <h3 id="canopendoor(baseplayer-player,-baselock-lock)">CanOpenDoor(BasePlayer player, BaseLock lock)</h3> <ul> <li>Called from BaseLock.OnTryToOpen and BaseLock.OnTryToClose</li> <li>Returning true will allow door usage, nothing will by default will allow door usage, returning anything else will reject door usage</li> </ul> <h3 id="canopendoor(baseplayer-player,-codelock-lock)">CanOpenDoor(BasePlayer player, CodeLock lock)</h3> <ul> <li>Called from CodeLock.OnTryToOpen and CodeLock.OnTryToClose</li> <li>Returning true will allow door usage, nothing will by default will allow door usage, returning anything else will reject door usage</li> </ul> <h3 id="canopendoor(baseplayer-player,-keylock-lock)">CanOpenDoor(BasePlayer player, KeyLock lock)</h3> <ul> <li>Called from KeyLock.OnTryToOpen and KeyLock.OnTryToClose</li> <li>Returning true will allow door usage, nothing will by default will allow door usage, returning anything else will reject door usage</li> </ul> <h3 id="onentitybuilt(planner-planner,-unityengine/gameobject-object)">OnEntityBuilt(Planner planner, UnityEngine/GameObject object)</h3> <ul> <li>Called from Item.Modules.Planner</li> <li>No return behavior</li> <li>Called when any structure is built (walls, ceilings, stairs, etc.)</li> </ul> <h3 id="onbuildingblockupgrade(buildingblock-block,-baseplayer-player,-buildinggrade.enum-grade)">OnBuildingBlockUpgrade(BuildingBlock block, BasePlayer player, BuildingGrade.Enum grade)</h3> <ul> <li>Called from BuildingBlock.DoUpgradeToGrade</li> <li>Returning a BuildingGrade.Enum grade will change the grade that will be upgraded to</li> <li>Called when a player upgrades the grade of a BuildingBlock</li> </ul> <h3 id="onbuildingblockrotate(buildingblock-block,-baseplayer-player)">OnBuildingBlockRotate(BuildingBlock block, BasePlayer player)</h3> <ul> <li>Called from BuildingBlock.DoRotation</li> <li>No return behavior</li> <li>Called when a player rotates a BuildingBlock</li> </ul> <h3 id="onbuildingblockdemolish(buildingblock-block,-baseplayer-player)">OnBuildingBlockDemolish(BuildingBlock block, BasePlayer player)</h3> <ul> <li>Called from BuildingBlock.DoImmediateDemolish</li> <li>Return true to cancel</li> <li>Called when a player selects DemolishImmediate from the BuildingBlock menu</li> </ul> </div> <div class=dark-box> </div> </div> </body> </html>